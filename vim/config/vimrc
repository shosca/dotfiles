" Modeline and Notes {
" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker spell:
" }

" Runtime {

    " Basics {
    set nocompatible
    filetype plugin indent on   " Automatically detect file types.
    " }

    let g:python_host_prog = '/usr/bin/python2'
    let g:python3_host_prog = '/usr/bin/python3'

    let $VIMPATH = fnamemodify(resolve(expand('<sfile>:p')), ':h:h')
    let $VARPATH = expand(($XDG_CACHE_HOME ? $XDG_CACHE_HOME : '~/.cache').'/vim')
    let $PLUGINPATH = expand('$VIMPATH/config/plugins')

    if !isdirectory(expand($VARPATH))
      call mkdir(expand($VARPATH), 'p')
    endif

    " The default leader is '\', but many people prefer ',' as it's in a standard
    " location.
    let mapleader = "\<Space>"
    let maplocalleader = ","
    let g:unite_leader = "f"

    " Identify platform {
    silent function! OSX()
        return has('macunix')
    endfunction
    silent function! LINUX()
        return has('unix') && !has('macunix') && !has('win32unix')
    endfunction
    silent function! WINDOWS()
        return  (has('win32') || has('win64'))
    endfunction
    " }

    " Windows Compatible {
    " On Windows, also use '.vim' instead of 'vimfiles'; this makes synchronization
    " across (heterogeneous) systems easier.
    if WINDOWS()
      set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
    endif
    " }

    " Arrow Key Fix {
    if &term[:4] == "xterm" || &term[:5] == 'screen' || &term[:3] == 'rxvt'
        inoremap <silent> <C-[>OC <RIGHT>
    endif
    " }

" }

" Functions {

    function! InitializeDirectories() " {
        let dir_list = {
                    \ 'backup': 'backupdir',
                    \ 'views': 'viewdir',
                    \ 'swap': 'directory' }

        if has('persistent_undo')
            let dir_list['undo'] = 'undodir'
        endif

        for [dirname, settingname] in items(dir_list)
            let s:dir = expand('$VARPATH/vim/' . dirname)
            if !isdirectory(s:dir)
                call mkdir(s:dir, 'p')
            endif
            if !isdirectory(s:dir)
                echo "Warning: Unable to create backup directory: " . directory
                echo "Try: mkdir -p " . s:dir
            else
                let s:dir = substitute(s:dir, " ", "\\\\ ", "g")
                exec "set " . settingname . "=" . s:dir
            endif
        endfor
    endfunction
    call InitializeDirectories()
    " }

    function! StripTrailingWhitespace() " {
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " do the business:
        %s/\s\+$//e
        " clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
    " }

    function! s:source_file(path, ...) abort "{
        let use_global = get(a:000, 0, ! has('vim_starting'))
        let abspath = resolve(expand($VIMPATH.'/config/'.a:path))
        if ! use_global
            execute 'source' fnameescape(abspath)
            return
        endif

        let content = map(readfile(abspath),
            \ "substitute(v:val, '^\\W*\\zsset\\ze\\W', 'setglobal', '')")
        let tempfile = tempname()
        try
            call writefile(content, tempfile)
            execute printf('source %s', fnameescape(tempfile))
        finally
            if filereadable(tempfile)
                call delete(tempfile)
            endif
        endtry

    endfunction

    " }

    function! s:dein_load_yaml(filename) abort " {
python << endpython
import vim, yaml
with open(vim.eval('a:filename'), 'r') as f:
    vim.vars['denite_plugins'] = yaml.load(f.read())
endpython
        for plugin in g:denite_plugins
            call dein#add(plugin['repo'], extend(plugin, {}, 'keep'))
            if has_key(plugin, 'hook_always')
                execute plugin['hook_always']
            endif
        endfor
        unlet g:denite_plugins
    endfunction " }

" }

" Dein {

if &runtimepath !~# '/dein.vim'
    let s:dein_dir = expand('$VARPATH/dein').'repos/github.com/Shougo/dein.vim'
    if ! isdirectory(s:dein_dir)
        execute '!git clone https://github.com/Shougo/dein.vim' s:dein_dir
    endif

    execute 'set runtimepath+='.substitute(fnamemodify(s:dein_dir, ':p'), '/$', '', '')
endif

let s:path = expand('$VARPATH/dein')
let s:plugins_paths = [
            \ expand('<sfile>'),
            \ expand('$PLUGINPATH/core.yaml'),
            \ expand('$PLUGINPATH/autocomplete.yaml'),
            \ expand('$PLUGINPATH/git.yaml'),
            \ expand('$PLUGINPATH/go.yaml'),
            \ expand('$PLUGINPATH/javascript.yaml'),
            \ expand('$PLUGINPATH/ruby.yaml'),
            \ expand('$PLUGINPATH/python.yaml'),
            \ expand('$PLUGINPATH/rust.yaml'),
            \ expand('$PLUGINPATH/sql.yaml'),
            \ expand('$PLUGINPATH/themes.yaml'),
            \ expand('$PLUGINPATH/vim.yaml'),
            \ ]
if dein#load_state(s:path)
    call dein#begin(s:path, s:plugins_paths)

    for plugins_path in s:plugins_paths[1:-1]
        try
            call s:dein_load_yaml(plugins_path)
        catch /.*/
            echomsg v:exception
            echomsg 'Error loading config/plugins.yaml...'
            echomsg 'Caught: ' v:exception
        endtry
    endfor

    if isdirectory(expand('$VIMPATH/dev'))
        call dein#local(expand('$VIMPATH/dev'), {'frozen': 1, 'merged': 0})
    endif
    call dein#end()
    call dein#save_state()

    if dein#check_install()
        if ! has('nvim')
            set nomore
        endif
        call dein#install()
    endif
endif
call dein#call_hook('source')

" }

" Colors and visuals {

    set termguicolors
    let base16colorspace=256
    set background=dark
    colorscheme gruvbox

    set tabpagemax=15               " Only show 15 tabs
    set showmode                    " Display the current mode

    " this is a performance killer
    "set cursorline                  " Highlight current line

    highlight clear SignColumn      " SignColumn should match background
    highlight clear LineNr          " Current line number row will have same background color in relative mode
    "highlight clear CursorLineNr    " Remove highlight color from current line number

    if has('cmdline_info')
        set ruler                   " Show the ruler
        set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
        set showcmd                 " Show partial commands in status line and
                                    " Selected characters/lines in visual mode
    endif

    if has('statusline')
        set laststatus=2

        " Broken down into easily includeable segments
        set statusline=%<%f\                     " Filename
        set statusline+=%w%h%m%r                 " Options

        set statusline+=%{fugitive#statusline()} " Git Hotness

        set statusline+=\ [%{&ff}/%Y]            " Filetype
        set statusline+=\ [%{getcwd()}]          " Current dir
        set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info
    endif

    set backspace=indent,eol,start  " Backspace for dummies
    set linespace=0                 " No extra spaces between rows
    set number                      " Line numbers on
    "set showmatch                   " Show matching brackets/parenthesis
    set incsearch                   " Find as you type search
    set hlsearch                    " Highlight search terms
    set winminheight=0              " Windows can be 0 line high
    set ignorecase                  " Case insensitive search
    set smartcase                   " Case sensitive when uc present
    set wildmenu                    " Show list instead of just completing
    set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
    set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*
    set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
    set scrolljump=5                " Lines to scroll when cursor leaves screen
    set scrolloff=3                 " Minimum lines to keep above and below cursor
    set foldenable                  " Auto fold code
    set list
    set listchars=tab:›\ ,eol:¬,trail:•,extends:#,nbsp:. " Highlight problematic whitespace

" }

call s:source_file('general.vim')
call s:source_file('mappings.vim')

" Formatting {

    "set comments=sl:/*,mb:*,elx:*/  " auto format comment blocks
    hi MatchParen cterm=bold term=bold

    " Remove trailing whitespaces and ^M chars
    autocmd FileType c,cpp,java,go,php,javascript,puppet,python,rust,twig,xml,xsl,xslt,html,yml,perl,sql autocmd BufWritePre <buffer> call StripTrailingWhitespace()
    autocmd FileType go autocmd BufWritePre <buffer> Fmt
    autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
    autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth=2 softtabstop=2

    autocmd BufNewFile,BufRead *.coffee set filetype=coffee

    " Workaround vim-commentary for Haskell
    autocmd FileType haskell setlocal commentstring=--\ %s

    " Workaround broken colour highlighting in Haskell
    autocmd FileType haskell,rust setlocal nospell

    " Instead of reverting the cursor to the last position in the buffer, we
    " set it to the first line when editing a git commit message
    au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

    autocmd FileType ruby,haml,eruby,yaml,html,sass,cucumber,sh set ai sw=2 sts=2 et
    autocmd FileType make set noexpandtab
    autocmd FileType json,jsonp set foldmethod=syntax
    augroup vagrant
        au!
        au BufRead,BufNewFile Vagrantfile set filetype=ruby
    augroup END

    autocmd BufWritePre,BufRead,BufNewFile *.css,*.scss,*.less setlocal foldmethod=marker foldmarker={,}
" }


" GUI Settings {

    " GVIM- (here instead of .gvimrc)
    if has('gui_running')
        set guioptions-=T           " Remove the toolbar
        set lines=40                " 40 lines of text instead of 24
        if LINUX() && has("gui_running")
            set guifont=Hack\ 9
        elseif OSX() && has("gui_running")
            set guifont=Hack\ 9
        elseif WINDOWS() && has("gui_running")
            set guifont=Hack:h10
        endif
    else
        if &term == 'xterm' || &term == 'screen'
            set t_Co=256            " Enable 256 colors to stop the CSApprox warning and make xterm vim shine
        endif
        "set term=builtin_ansi       " Make arrow and other keys work
    endif

" }

" { Local config
if filereadable(expand("~/.config/nvim/init.local.vim"))
    source ~/.config/nvim/init.local.vim
endif
" }
